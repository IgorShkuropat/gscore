/* tslint:disable */
/* eslint-disable */
/**
 * G-score api
 * g-score
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base';

/**
 *
 * @export
 * @interface ActivateLicenseCodeBodyDto
 */
export interface ActivateLicenseCodeBodyDto {
  /**
   *
   * @type {string}
   * @memberof ActivateLicenseCodeBodyDto
   */
  code: string;
}
/**
 *
 * @export
 * @interface AuthResponseDto
 */
export interface AuthResponseDto {
  /**
   *
   * @type {string}
   * @memberof AuthResponseDto
   */
  token: string;
  /**
   *
   * @type {AuthResponseDtoUser}
   * @memberof AuthResponseDto
   */
  user: AuthResponseDtoUser;
}
/**
 *
 * @export
 * @interface AuthResponseDtoUser
 */
export interface AuthResponseDtoUser {
  /**
   *
   * @type {number}
   * @memberof AuthResponseDtoUser
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof AuthResponseDtoUser
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof AuthResponseDtoUser
   */
  username: string;
  /**
   *
   * @type {Array<SubscribeResponse>}
   * @memberof AuthResponseDtoUser
   */
  subscribes: Array<SubscribeResponseDto> | null;
  /**
   *
   * @type {Array<LicenceCodeResponseDto>}
   * @memberof AuthResponseDtoUser
   */
  codes: Array<LicenceCodeResponseDto> | null;
}
/**
 *
 * @export
 * @interface BuySubscribeDto
 */
export interface BuySubscribeDto {
  /**
   *
   * @type {number}
   * @memberof BuySubscribeDto
   */
  priceId: number;
}
/**
 *
 * @export
 * @interface BuySubscribeResponseDto
 */
export interface BuySubscribeResponseDto {
  /**
   *
   * @type {BuySubscribeResponseDtoSubscribe}
   * @memberof BuySubscribeResponseDto
   */
  subscribe: BuySubscribeResponseDtoSubscribe;
}
/**
 *
 * @export
 * @interface BuySubscribeResponseDtoSubscribe
 */
export interface BuySubscribeResponseDtoSubscribe {
  /**
   *
   * @type {number}
   * @memberof BuySubscribeResponseDtoSubscribe
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof BuySubscribeResponseDtoSubscribe
   */
  userId: number;
  /**
   *
   * @type {number}
   * @memberof BuySubscribeResponseDtoSubscribe
   */
  currentPeriodStart: number | null;
  /**
   *
   * @type {number}
   * @memberof BuySubscribeResponseDtoSubscribe
   */
  currentPeriodEnd: number | null;
}
/**
 *
 * @export
 * @interface ChangePersonalDataDto
 */
export interface ChangePersonalDataDto {
  /**
   *
   * @type {string}
   * @memberof ChangePersonalDataDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof ChangePersonalDataDto
   */
  username: string;
}
/**
 *
 * @export
 * @interface ChangeSubscribeProductDto
 */
export interface ChangeSubscribeProductDto {
  /**
   *
   * @type {number}
   * @memberof ChangeSubscribeProductDto
   */
  productId: number;
  /**
   *
   * @type {number}
   * @memberof ChangeSubscribeProductDto
   */
  subscribeId: number;
}
/**
 *
 * @export
 * @interface CodeHealthDto
 */
export interface CodeHealthDto {
  /**
   *
   * @type {string}
   * @memberof CodeHealthDto
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof CodeHealthDto
   */
  origin: string;
  /**
   *
   * @type {string}
   * @memberof CodeHealthDto
   */
  status: CodeHealthDtoStatusEnum;
  /**
   *
   * @type {number}
   * @memberof CodeHealthDto
   */
  currentPeriodStart: number | null;
  /**
   *
   * @type {number}
   * @memberof CodeHealthDto
   */
  currentPeriodEnd: number | null;
}

export const CodeHealthDtoStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Hold: 'HOLD',
} as const;

export type CodeHealthDtoStatusEnum =
  typeof CodeHealthDtoStatusEnum[keyof typeof CodeHealthDtoStatusEnum];

/**
 *
 * @export
 * @interface LicenceCodeHasBeenActivatedError
 */
export interface LicenceCodeHasBeenActivatedError {
  /**
   *
   * @type {number}
   * @memberof LicenceCodeHasBeenActivatedError
   */
  statusCode: number;
  /**
   *
   * @type {string}
   * @memberof LicenceCodeHasBeenActivatedError
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof LicenceCodeHasBeenActivatedError
   */
  error: string;
}
/**
 *
 * @export
 * @interface LicenceCodeIsHoldError
 */
export interface LicenceCodeIsHoldError {
  /**
   *
   * @type {number}
   * @memberof LicenceCodeIsHoldError
   */
  statusCode: number;
  /**
   *
   * @type {string}
   * @memberof LicenceCodeIsHoldError
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof LicenceCodeIsHoldError
   */
  error: string;
}
/**
 *
 * @export
 * @interface LicenceCodeResponseDto
 */
export interface LicenceCodeResponseDto {
  /**
   *
   * @type {number}
   * @memberof LicenceCodeResponseDto
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof LicenceCodeResponseDto
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof LicenceCodeResponseDto
   */
  origin: string;
  /**
   *
   * @type {string}
   * @memberof LicenceCodeResponseDto
   */
  status: LicenceCodeResponseDtoStatusEnum;
  /**
   *
   * @type {number}
   * @memberof LicenceCodeResponseDto
   */
  subscribeId: number;
  /**
   *
   * @type {LicenceCodeResponseDtoSubscribe}
   * @memberof LicenceCodeResponseDto
   */
  subscribe: LicenceCodeResponseDtoSubscribe | null;
  /**
   *
   * @type {number}
   * @memberof LicenceCodeResponseDto
   */
  userId: number;
  /**
   *
   * @type {SubscribeResponseDtoUser}
   * @memberof LicenceCodeResponseDto
   */
  user: SubscribeResponseDtoUser | null;
}

export const LicenceCodeResponseDtoStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Hold: 'HOLD',
} as const;

export type LicenceCodeResponseDtoStatusEnum =
  typeof LicenceCodeResponseDtoStatusEnum[keyof typeof LicenceCodeResponseDtoStatusEnum];

/**
 *
 * @export
 * @interface LicenceCodeResponseDtoSubscribe
 */
export interface LicenceCodeResponseDtoSubscribe {
  /**
   *
   * @type {number}
   * @memberof LicenceCodeResponseDtoSubscribe
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof LicenceCodeResponseDtoSubscribe
   */
  userId: number;
  /**
   *
   * @type {SubscribeResponseDtoUser}
   * @memberof LicenceCodeResponseDtoSubscribe
   */
  user: SubscribeResponseDtoUser | null;
  /**
   *
   * @type {number}
   * @memberof LicenceCodeResponseDtoSubscribe
   */
  productId: number;
  /**
   *
   * @type {SubscribeResponseDtoProduct}
   * @memberof LicenceCodeResponseDtoSubscribe
   */
  product: SubscribeResponseDtoProduct | null;
  /**
   *
   * @type {string}
   * @memberof LicenceCodeResponseDtoSubscribe
   */
  currentPeriodStart: string | null;
  /**
   *
   * @type {string}
   * @memberof LicenceCodeResponseDtoSubscribe
   */
  currentPeriodEnd: string | null;
  /**
   *
   * @type {string}
   * @memberof LicenceCodeResponseDtoSubscribe
   */
  status: LicenceCodeResponseDtoSubscribeStatusEnum;
  /**
   *
   * @type {Array<LicenceCodeResponseDto>}
   * @memberof LicenceCodeResponseDtoSubscribe
   */
  codes: Array<LicenceCodeResponseDto> | null;
}

export const LicenceCodeResponseDtoSubscribeStatusEnum = {
  Active: 'ACTIVE',
  Unpaid: 'UNPAID',
  Canceled: 'CANCELED',
} as const;

export type LicenceCodeResponseDtoSubscribeStatusEnum =
  typeof LicenceCodeResponseDtoSubscribeStatusEnum[keyof typeof LicenceCodeResponseDtoSubscribeStatusEnum];

/**
 *
 * @export
 * @interface LicenseCode
 */
export interface LicenseCode {
  /**
   *
   * @type {number}
   * @memberof LicenseCode
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof LicenseCode
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof LicenseCode
   */
  origin: string;
  /**
   *
   * @type {string}
   * @memberof LicenseCode
   */
  status: LicenseCodeStatusEnum;
  /**
   *
   * @type {number}
   * @memberof LicenseCode
   */
  subscribeId: number;
  /**
   *
   * @type {LicenseCodeSubscribe}
   * @memberof LicenseCode
   */
  subscribe: LicenseCodeSubscribe | null;
  /**
   *
   * @type {number}
   * @memberof LicenseCode
   */
  userId: number;
  /**
   *
   * @type {object}
   * @memberof LicenseCode
   */
  user: object | null;
}

export const LicenseCodeStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Hold: 'HOLD',
} as const;

export type LicenseCodeStatusEnum =
  typeof LicenseCodeStatusEnum[keyof typeof LicenseCodeStatusEnum];

/**
 * @type LicenseCodeControllerActivateCode409Response
 * @export
 */
export type LicenseCodeControllerActivateCode409Response =
  | LicenceCodeHasBeenActivatedError
  | LicenceCodeIsHoldError;

/**
 * @type LicenseCodeControllerManageLicenseCodes409Response
 * @export
 */
export type LicenseCodeControllerManageLicenseCodes409Response =
  | ManageLicenseCodesErrorDto
  | NotAllCodesApplyForSubscribeErrorDto;

/**
 *
 * @export
 * @interface LicenseCodeSubscribe
 */
export interface LicenseCodeSubscribe {
  /**
   *
   * @type {number}
   * @memberof LicenseCodeSubscribe
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof LicenseCodeSubscribe
   */
  userId: number;
  /**
   *
   * @type {number}
   * @memberof LicenseCodeSubscribe
   */
  currentPeriodStart: number | null;
  /**
   *
   * @type {number}
   * @memberof LicenseCodeSubscribe
   */
  currentPeriodEnd: number | null;
}
/**
 *
 * @export
 * @interface ManageLicenseCodesDto
 */
export interface ManageLicenseCodesDto {
  /**
   *
   * @type {Array<number>}
   * @memberof ManageLicenseCodesDto
   */
  codesIds: Array<number>;
  /**
   *
   * @type {number}
   * @memberof ManageLicenseCodesDto
   */
  subscribeId: number;
}
/**
 *
 * @export
 * @interface ManageLicenseCodesErrorDto
 */
export interface ManageLicenseCodesErrorDto {
  /**
   *
   * @type {number}
   * @memberof ManageLicenseCodesErrorDto
   */
  statusCode: number;
  /**
   *
   * @type {string}
   * @memberof ManageLicenseCodesErrorDto
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof ManageLicenseCodesErrorDto
   */
  error: string;
}
/**
 *
 * @export
 * @interface NotAllCodesApplyForSubscribeErrorDto
 */
export interface NotAllCodesApplyForSubscribeErrorDto {
  /**
   *
   * @type {number}
   * @memberof NotAllCodesApplyForSubscribeErrorDto
   */
  statusCode: number;
  /**
   *
   * @type {string}
   * @memberof NotAllCodesApplyForSubscribeErrorDto
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof NotAllCodesApplyForSubscribeErrorDto
   */
  error: string;
}
/**
 *
 * @export
 * @interface NotFoundLicenseCode
 */
export interface NotFoundLicenseCode {
  /**
   *
   * @type {number}
   * @memberof NotFoundLicenseCode
   */
  statusCode: number;
  /**
   *
   * @type {string}
   * @memberof NotFoundLicenseCode
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof NotFoundLicenseCode
   */
  error: string;
}
/**
 *
 * @export
 * @interface NumberOfAvailableCodesErrorDto
 */
export interface NumberOfAvailableCodesErrorDto {
  /**
   *
   * @type {number}
   * @memberof NumberOfAvailableCodesErrorDto
   */
  statusCode: number;
  /**
   *
   * @type {string}
   * @memberof NumberOfAvailableCodesErrorDto
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof NumberOfAvailableCodesErrorDto
   */
  error: string;
}
/**
 *
 * @export
 * @interface PriceResponseDto
 */
export interface PriceResponseDto {
  /**
   *
   * @type {number}
   * @memberof PriceResponseDto
   */
  id: number;
  /**
   *
   * @type {boolean}
   * @memberof PriceResponseDto
   */
  isActive: boolean;
  /**
   *
   * @type {number}
   * @memberof PriceResponseDto
   */
  productId: number;
  /**
   *
   * @type {object}
   * @memberof PriceResponseDto
   */
  product: object | null;
  /**
   *
   * @type {string}
   * @memberof PriceResponseDto
   */
  price: string;
}
/**
 *
 * @export
 * @interface ProductResponseDto
 */
export interface ProductResponseDto {
  /**
   *
   * @type {number}
   * @memberof ProductResponseDto
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof ProductResponseDto
   */
  sitesCount: number;
  /**
   *
   * @type {number}
   * @memberof ProductResponseDto
   */
  name: string;
  /**
   *
   * @type {Array<PriceResponseDto>}
   * @memberof ProductResponseDto
   */
  prices: Array<PriceResponseDto> | null;
}
/**
 *
 * @export
 * @interface SignInDto
 */
export interface SignInDto {
  /**
   *
   * @type {string}
   * @memberof SignInDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof SignInDto
   */
  password: string;
}
/**
 *
 * @export
 * @interface SignUpDto
 */
export interface SignUpDto {
  /**
   *
   * @type {string}
   * @memberof SignUpDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof SignUpDto
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof SignUpDto
   */
  password: string;
}
/**
 *
 * @export
 * @interface SignUpResponseDto
 */
export interface SignUpResponseDto {
  /**
   *
   * @type {string}
   * @memberof SignUpResponseDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof SignUpResponseDto
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof SignUpResponseDto
   */
  token: string;
}
/**
 *
 * @export
 * @interface Subscribe
 */
export interface Subscribe {
  /**
   *
   * @type {number}
   * @memberof Subscribe
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof Subscribe
   */
  userId: number;
  /**
   *
   * @type {number}
   * @memberof Subscribe
   */
  currentPeriodStart: number | null;
  /**
   *
   * @type {number}
   * @memberof Subscribe
   */
  currentPeriodEnd: number | null;
}
/**
 *
 * @export
 * @interface SubscribeNotFoundErrorDto
 */
export interface SubscribeNotFoundErrorDto {
  /**
   *
   * @type {number}
   * @memberof SubscribeNotFoundErrorDto
   */
  statusCode: number;
  /**
   *
   * @type {string}
   * @memberof SubscribeNotFoundErrorDto
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof SubscribeNotFoundErrorDto
   */
  error: string;
}
/**
 *
 * @export
 * @interface SubscribeResponseDto
 */
export interface SubscribeResponseDto {
  /**
   *
   * @type {number}
   * @memberof SubscribeResponseDto
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof SubscribeResponseDto
   */
  userId: number;
  /**
   *
   * @type {SubscribeResponseDtoUser}
   * @memberof SubscribeResponseDto
   */
  user: SubscribeResponseDtoUser | null;
  /**
   *
   * @type {number}
   * @memberof SubscribeResponseDto
   */
  productId: number;
  /**
   *
   * @type {SubscribeResponseDtoProduct}
   * @memberof SubscribeResponseDto
   */
  product: SubscribeResponseDtoProduct | null;
  /**
   *
   * @type {string}
   * @memberof SubscribeResponseDto
   */
  currentPeriodStart: string | null;
  /**
   *
   * @type {string}
   * @memberof SubscribeResponseDto
   */
  currentPeriodEnd: string | null;
  /**
   *
   * @type {string}
   * @memberof SubscribeResponseDto
   */
  status: SubscribeResponseDtoStatusEnum;
  /**
   *
   * @type {Array<LicenceCodeResponseDto>}
   * @memberof SubscribeResponseDto
   */
  codes: Array<LicenceCodeResponseDto> | null;
}

export const SubscribeResponseDtoStatusEnum = {
  Active: 'ACTIVE',
  Unpaid: 'UNPAID',
  Canceled: 'CANCELED',
} as const;

export type SubscribeResponseDtoStatusEnum =
  typeof SubscribeResponseDtoStatusEnum[keyof typeof SubscribeResponseDtoStatusEnum];

/**
 *
 * @export
 * @interface SubscribeResponseDtoProduct
 */
export interface SubscribeResponseDtoProduct {
  /**
   *
   * @type {number}
   * @memberof SubscribeResponseDtoProduct
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof SubscribeResponseDtoProduct
   */
  sitesCount: number;
  /**
   *
   * @type {number}
   * @memberof SubscribeResponseDtoProduct
   */
  name: number;
  /**
   *
   * @type {Array<PriceResponseDto>}
   * @memberof SubscribeResponseDtoProduct
   */
  prices: Array<PriceResponseDto> | null;
}
/**
 *
 * @export
 * @interface SubscribeResponseDtoUser
 */
export interface SubscribeResponseDtoUser {
  /**
   *
   * @type {number}
   * @memberof SubscribeResponseDtoUser
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof SubscribeResponseDtoUser
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof SubscribeResponseDtoUser
   */
  username: string;
  /**
   *
   * @type {Array<Array>}
   * @memberof SubscribeResponseDtoUser
   */
  subscribes: Array<Array> | null;
  /**
   *
   * @type {Array<LicenceCodeResponseDto>}
   * @memberof SubscribeResponseDtoUser
   */
  codes: Array<LicenceCodeResponseDto> | null;
}
/**
 *
 * @export
 * @interface UpdatePasswordDto
 */
export interface UpdatePasswordDto {
  /**
   *
   * @type {string}
   * @memberof UpdatePasswordDto
   */
  currentPassword: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePasswordDto
   */
  newPassword: string;
}
/**
 *
 * @export
 * @interface UserResponseDto
 */

// type SubscribeResponse = {
//   userId: number;
//   productId: number;
//   currentPeriodStart: number;
//   currentPeriodEnd: number;
//   status: string;
//   id: number;
// };
export interface UserResponseDto {
  /**
   *
   * @type {number}
   * @memberof UserResponseDto
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UserResponseDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserResponseDto
   */
  username: string;
  /**
   *
   * @type {Array<Array>}
   * @memberof UserResponseDto
   */
  subscribes: Array<SubscribeResponse> | null;
  /**
   *
   * @type {Array<LicenceCodeResponseDto>}
   * @memberof UserResponseDto
   */
  codes: Array<LicenceCodeResponseDto> | null;
}

/**
 * CodeApi - axios parameter creator
 * @export
 */
export const CodeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Activate license code
     * @param {ActivateLicenseCodeBodyDto} activateLicenseCodeBodyDto
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    licenseCodeControllerActivateCode: async (
      activateLicenseCodeBodyDto: ActivateLicenseCodeBodyDto,
      origin?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'activateLicenseCodeBodyDto' is not null or undefined
      assertParamExists(
        'licenseCodeControllerActivateCode',
        'activateLicenseCodeBodyDto',
        activateLicenseCodeBodyDto,
      );
      const localVarPath = `/api/code/activate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (origin != null) {
        localVarHeaderParameter['Origin'] = String(origin);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        activateLicenseCodeBodyDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get license code health
     * @param {ActivateLicenseCodeBodyDto} activateLicenseCodeBodyDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    licenseCodeControllerGetLicenseCodeHealth: async (
      activateLicenseCodeBodyDto: ActivateLicenseCodeBodyDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'activateLicenseCodeBodyDto' is not null or undefined
      assertParamExists(
        'licenseCodeControllerGetLicenseCodeHealth',
        'activateLicenseCodeBodyDto',
        activateLicenseCodeBodyDto,
      );
      const localVarPath = `/api/code/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        activateLicenseCodeBodyDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get self license codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    licenseCodeControllerGetSelfLicencesCodes: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/code/self`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Manage self license codes
     * @param {ManageLicenseCodesDto} manageLicenseCodesDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    licenseCodeControllerManageLicenseCodes: async (
      manageLicenseCodesDto: ManageLicenseCodesDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'manageLicenseCodesDto' is not null or undefined
      assertParamExists(
        'licenseCodeControllerManageLicenseCodes',
        'manageLicenseCodesDto',
        manageLicenseCodesDto,
      );
      const localVarPath = `/api/code/manage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        manageLicenseCodesDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CodeApi - functional programming interface
 * @export
 */
export const CodeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CodeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Activate license code
     * @param {ActivateLicenseCodeBodyDto} activateLicenseCodeBodyDto
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async licenseCodeControllerActivateCode(
      activateLicenseCodeBodyDto: ActivateLicenseCodeBodyDto,
      origin?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseCode>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.licenseCodeControllerActivateCode(
          activateLicenseCodeBodyDto,
          origin,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get license code health
     * @param {ActivateLicenseCodeBodyDto} activateLicenseCodeBodyDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async licenseCodeControllerGetLicenseCodeHealth(
      activateLicenseCodeBodyDto: ActivateLicenseCodeBodyDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeHealthDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.licenseCodeControllerGetLicenseCodeHealth(
          activateLicenseCodeBodyDto,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get self license codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async licenseCodeControllerGetSelfLicencesCodes(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<LicenseCode>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.licenseCodeControllerGetSelfLicencesCodes(
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Manage self license codes
     * @param {ManageLicenseCodesDto} manageLicenseCodesDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async licenseCodeControllerManageLicenseCodes(
      manageLicenseCodesDto: ManageLicenseCodesDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<LicenseCode>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.licenseCodeControllerManageLicenseCodes(
          manageLicenseCodesDto,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * CodeApi - factory interface
 * @export
 */
export const CodeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CodeApiFp(configuration);
  return {
    /**
     *
     * @summary Activate license code
     * @param {ActivateLicenseCodeBodyDto} activateLicenseCodeBodyDto
     * @param {string} [origin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    licenseCodeControllerActivateCode(
      activateLicenseCodeBodyDto: ActivateLicenseCodeBodyDto,
      origin?: string,
      options?: any,
    ): AxiosPromise<LicenseCode> {
      return localVarFp
        .licenseCodeControllerActivateCode(
          activateLicenseCodeBodyDto,
          origin,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get license code health
     * @param {ActivateLicenseCodeBodyDto} activateLicenseCodeBodyDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    licenseCodeControllerGetLicenseCodeHealth(
      activateLicenseCodeBodyDto: ActivateLicenseCodeBodyDto,
      options?: any,
    ): AxiosPromise<CodeHealthDto> {
      return localVarFp
        .licenseCodeControllerGetLicenseCodeHealth(
          activateLicenseCodeBodyDto,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get self license codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    licenseCodeControllerGetSelfLicencesCodes(
      options?: any,
    ): AxiosPromise<Array<LicenseCode>> {
      return localVarFp
        .licenseCodeControllerGetSelfLicencesCodes(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Manage self license codes
     * @param {ManageLicenseCodesDto} manageLicenseCodesDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    licenseCodeControllerManageLicenseCodes(
      manageLicenseCodesDto: ManageLicenseCodesDto,
      options?: any,
    ): AxiosPromise<Array<LicenseCode>> {
      return localVarFp
        .licenseCodeControllerManageLicenseCodes(manageLicenseCodesDto, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * CodeApi - object-oriented interface
 * @export
 * @class CodeApi
 * @extends {BaseAPI}
 */
export class CodeApi extends BaseAPI {
  /**
   *
   * @summary Activate license code
   * @param {ActivateLicenseCodeBodyDto} activateLicenseCodeBodyDto
   * @param {string} [origin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CodeApi
   */
  public licenseCodeControllerActivateCode(
    activateLicenseCodeBodyDto: ActivateLicenseCodeBodyDto,
    origin?: string,
    options?: AxiosRequestConfig,
  ) {
    return CodeApiFp(this.configuration)
      .licenseCodeControllerActivateCode(
        activateLicenseCodeBodyDto,
        origin,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get license code health
   * @param {ActivateLicenseCodeBodyDto} activateLicenseCodeBodyDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CodeApi
   */
  public licenseCodeControllerGetLicenseCodeHealth(
    activateLicenseCodeBodyDto: ActivateLicenseCodeBodyDto,
    options?: AxiosRequestConfig,
  ) {
    return CodeApiFp(this.configuration)
      .licenseCodeControllerGetLicenseCodeHealth(
        activateLicenseCodeBodyDto,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get self license codes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CodeApi
   */
  public licenseCodeControllerGetSelfLicencesCodes(
    options?: AxiosRequestConfig,
  ) {
    return CodeApiFp(this.configuration)
      .licenseCodeControllerGetSelfLicencesCodes(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Manage self license codes
   * @param {ManageLicenseCodesDto} manageLicenseCodesDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CodeApi
   */
  public licenseCodeControllerManageLicenseCodes(
    manageLicenseCodesDto: ManageLicenseCodesDto,
    options?: AxiosRequestConfig,
  ) {
    return CodeApiFp(this.configuration)
      .licenseCodeControllerManageLicenseCodes(manageLicenseCodesDto, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Buy subscribe
     * @param {BuySubscribeDto} buySubscribeDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsControllerBuySubscribe: async (
      buySubscribeDto: BuySubscribeDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'buySubscribeDto' is not null or undefined
      assertParamExists(
        'paymentsControllerBuySubscribe',
        'buySubscribeDto',
        buySubscribeDto,
      );
      const localVarPath = `/api/payments/buy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        buySubscribeDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Buy subscribe
     * @param {BuySubscribeDto} buySubscribeDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentsControllerBuySubscribe(
      buySubscribeDto: BuySubscribeDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BuySubscribeResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentsControllerBuySubscribe(
          buySubscribeDto,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PaymentsApiFp(configuration);
  return {
    /**
     *
     * @summary Buy subscribe
     * @param {BuySubscribeDto} buySubscribeDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsControllerBuySubscribe(
      buySubscribeDto: BuySubscribeDto,
      options?: any,
    ): AxiosPromise<BuySubscribeResponseDto> {
      return localVarFp
        .paymentsControllerBuySubscribe(buySubscribeDto, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
  /**
   *
   * @summary Buy subscribe
   * @param {BuySubscribeDto} buySubscribeDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public paymentsControllerBuySubscribe(
    buySubscribeDto: BuySubscribeDto,
    options?: AxiosRequestConfig,
  ) {
    return PaymentsApiFp(this.configuration)
      .paymentsControllerBuySubscribe(buySubscribeDto, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get products list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsControllerGetProducts: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/products`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get products list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productsControllerGetProducts(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ProductResponseDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.productsControllerGetProducts(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProductsApiFp(configuration);
  return {
    /**
     *
     * @summary Get products list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsControllerGetProducts(
      options?: any,
    ): AxiosPromise<Array<ProductResponseDto>> {
      return localVarFp
        .productsControllerGetProducts(options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
  /**
   *
   * @summary Get products list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public productsControllerGetProducts(options?: AxiosRequestConfig) {
    return ProductsApiFp(this.configuration)
      .productsControllerGetProducts(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SubscribeApi - axios parameter creator
 * @export
 */
export const SubscribeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Change subscribe product
     * @param {ChangeSubscribeProductDto} changeSubscribeProductDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscribeControllerChangeSubscribeProduct: async (
      changeSubscribeProductDto: ChangeSubscribeProductDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'changeSubscribeProductDto' is not null or undefined
      assertParamExists(
        'subscribeControllerChangeSubscribeProduct',
        'changeSubscribeProductDto',
        changeSubscribeProductDto,
      );
      const localVarPath = `/api/subscribe/change-product`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        changeSubscribeProductDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get self subscribes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscribeControllerGetSelfSubscribe: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/subscribe/self`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SubscribeApi - functional programming interface
 * @export
 */
export const SubscribeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SubscribeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Change subscribe product
     * @param {ChangeSubscribeProductDto} changeSubscribeProductDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscribeControllerChangeSubscribeProduct(
      changeSubscribeProductDto: ChangeSubscribeProductDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SubscribeResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscribeControllerChangeSubscribeProduct(
          changeSubscribeProductDto,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get self subscribes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscribeControllerGetSelfSubscribe(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SubscribeResponseDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscribeControllerGetSelfSubscribe(
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SubscribeApi - factory interface
 * @export
 */
export const SubscribeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SubscribeApiFp(configuration);
  return {
    /**
     *
     * @summary Change subscribe product
     * @param {ChangeSubscribeProductDto} changeSubscribeProductDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscribeControllerChangeSubscribeProduct(
      changeSubscribeProductDto: ChangeSubscribeProductDto,
      options?: any,
    ): AxiosPromise<SubscribeResponseDto> {
      return localVarFp
        .subscribeControllerChangeSubscribeProduct(
          changeSubscribeProductDto,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get self subscribes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscribeControllerGetSelfSubscribe(
      options?: any,
    ): AxiosPromise<Array<SubscribeResponseDto>> {
      return localVarFp
        .subscribeControllerGetSelfSubscribe(options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * SubscribeApi - object-oriented interface
 * @export
 * @class SubscribeApi
 * @extends {BaseAPI}
 */
export class SubscribeApi extends BaseAPI {
  /**
   *
   * @summary Change subscribe product
   * @param {ChangeSubscribeProductDto} changeSubscribeProductDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscribeApi
   */
  public subscribeControllerChangeSubscribeProduct(
    changeSubscribeProductDto: ChangeSubscribeProductDto,
    options?: AxiosRequestConfig,
  ) {
    return SubscribeApiFp(this.configuration)
      .subscribeControllerChangeSubscribeProduct(
        changeSubscribeProductDto,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get self subscribes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscribeApi
   */
  public subscribeControllerGetSelfSubscribe(options?: AxiosRequestConfig) {
    return SubscribeApiFp(this.configuration)
      .subscribeControllerGetSelfSubscribe(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerGetMe: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/users/me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sign in
     * @param {SignInDto} signInDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSignIn: async (
      signInDto: SignInDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'signInDto' is not null or undefined
      assertParamExists('usersControllerSignIn', 'signInDto', signInDto);
      const localVarPath = `/api/users/sign-in`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signInDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sign up
     * @param {SignUpDto} signUpDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSignUp: async (
      signUpDto: SignUpDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'signUpDto' is not null or undefined
      assertParamExists('usersControllerSignUp', 'signUpDto', signUpDto);
      const localVarPath = `/api/users/sign-up`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signUpDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update password
     * @param {UpdatePasswordDto} updatePasswordDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerUpdatePassword: async (
      updatePasswordDto: UpdatePasswordDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePasswordDto' is not null or undefined
      assertParamExists(
        'usersControllerUpdatePassword',
        'updatePasswordDto',
        updatePasswordDto,
      );
      const localVarPath = `/api/users/update-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePasswordDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update personal data
     * @param {ChangePersonalDataDto} changePersonalDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerUpdatePersonalData: async (
      changePersonalDataDto: ChangePersonalDataDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'changePersonalDataDto' is not null or undefined
      assertParamExists(
        'usersControllerUpdatePersonalData',
        'changePersonalDataDto',
        changePersonalDataDto,
      );
      const localVarPath = `/api/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        changePersonalDataDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerGetMe(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerGetMe(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Sign in
     * @param {SignInDto} signInDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerSignIn(
      signInDto: SignInDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AuthResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerSignIn(
          signInDto,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Sign up
     * @param {SignUpDto} signUpDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerSignUp(
      signUpDto: SignUpDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SignUpResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerSignUp(
          signUpDto,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Update password
     * @param {UpdatePasswordDto} updatePasswordDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerUpdatePassword(
      updatePasswordDto: UpdatePasswordDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerUpdatePassword(
          updatePasswordDto,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Update personal data
     * @param {ChangePersonalDataDto} changePersonalDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerUpdatePersonalData(
      changePersonalDataDto: ChangePersonalDataDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerUpdatePersonalData(
          changePersonalDataDto,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary Get me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerGetMe(options?: any): AxiosPromise<UserResponseDto> {
      return localVarFp
        .usersControllerGetMe(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Sign in
     * @param {SignInDto} signInDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSignIn(
      signInDto: SignInDto,
      options?: any,
    ): AxiosPromise<AuthResponseDto> {
      return localVarFp
        .usersControllerSignIn(signInDto, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Sign up
     * @param {SignUpDto} signUpDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSignUp(
      signUpDto: SignUpDto,
      options?: any,
    ): AxiosPromise<SignUpResponseDto> {
      return localVarFp
        .usersControllerSignUp(signUpDto, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Update password
     * @param {UpdatePasswordDto} updatePasswordDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerUpdatePassword(
      updatePasswordDto: UpdatePasswordDto,
      options?: any,
    ): AxiosPromise<UserResponseDto> {
      return localVarFp
        .usersControllerUpdatePassword(updatePasswordDto, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Update personal data
     * @param {ChangePersonalDataDto} changePersonalDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerUpdatePersonalData(
      changePersonalDataDto: ChangePersonalDataDto,
      options?: any,
    ): AxiosPromise<UserResponseDto> {
      return localVarFp
        .usersControllerUpdatePersonalData(changePersonalDataDto, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary Get me
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerGetMe(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .usersControllerGetMe(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Sign in
   * @param {SignInDto} signInDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerSignIn(
    signInDto: SignInDto,
    options?: AxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerSignIn(signInDto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Sign up
   * @param {SignUpDto} signUpDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerSignUp(
    signUpDto: SignUpDto,
    options?: AxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerSignUp(signUpDto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update password
   * @param {UpdatePasswordDto} updatePasswordDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerUpdatePassword(
    updatePasswordDto: UpdatePasswordDto,
    options?: AxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerUpdatePassword(updatePasswordDto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update personal data
   * @param {ChangePersonalDataDto} changePersonalDataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersControllerUpdatePersonalData(
    changePersonalDataDto: ChangePersonalDataDto,
    options?: AxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .usersControllerUpdatePersonalData(changePersonalDataDto, options)
      .then(request => request(this.axios, this.basePath));
  }
}
